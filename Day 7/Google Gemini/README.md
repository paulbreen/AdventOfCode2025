ðŸš€ Tachyon Manifold SolverThis project solves two related puzzles involving the simulation of a beam/particle traveling through a 2D grid representing a tachyon manifold.Language ChosenPythonPython was selected for its ease of data manipulation (handling the 2D grid input) and its suitability for implementing graph traversal and dynamic programming algorithms. The grid traversal logic for both puzzles is straightforward, and Python's readability ensures a clean and efficient solution without the overhead of compilation. The performance of Python for the given input size is more than sufficient.PrerequisitesLanguage Version: Python 3.6+Runtime: Standard Python runtime environment.Build InstructionsNo compilation is required. The solution is executed directly via the Python interpreter.Run CommandEnsure that the input file (input.txt) is in the same directory as the script (tachyon_solver.py).Bashpython tachyon_solver.py
DependenciesThere are no external dependencies. The solution uses only the Python built-in sys and time modules.Puzzles OverviewPuzzle 1: Classical Tachyon ManifoldThe puzzle involves a simulation where a single beam moves downward. A splitter (^) stops the incoming beam and creates two new beams, one to the immediate left and one to the immediate right, one row below. The goal is to count the total number of times a splitter is hit and produces new beams.Approach: An iterative simulation is used, tracking the set of active columns that carry a downward beam. A set is used to ensure a splitter is counted only once per row, as multiple beams may converge on the same splitter.Puzzle 2: Quantum Tachyon Manifold (Timelines)The puzzle involves a single particle where a splitter causes the particle to take both the left and right paths (many-worlds interpretation), splitting the timeline. The goal is to count the total number of distinct timelines active after the particle completes all possible journeys.Approach: This is modeled as a path-counting problem on a Directed Acyclic Graph (DAG). Dynamic Programming (DP) is used, where $DP[r][c]$ stores the total number of timelines (paths) reaching cell $(r, c)$. Paths from 'S' and splitters ('^') contribute to the left and right columns in the next row, while paths from empty spaces ('.') contribute to the same column in the next row. The final result is the sum of paths in the row immediately following the last row of the grid.